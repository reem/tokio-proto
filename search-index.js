var searchIndex = {};
searchIndex["tokio_proto"] = {"doc":"A collection of components for rapid protocol development","items":[[3,"Framed","tokio_proto","FramedIo handling frame encoding and decoding.",null,null],[0,"multiplex","","Dispatch for multiplexed protocols",null,null],[3,"Server","tokio_proto::multiplex","A server `Task` that dispatches `Transport` messages to a `Service` using\nprotocol multiplexing.",null,null],[4,"Frame","","A multiplexed protocol frame",null,null],[13,"Message","","Either a request or a response",0,null],[13,"MessageWithBody","","Returned by `Transport::read` when a streaming body will follow.\nSubsequent body frames with a matching `RequestId` will be proxied to\nthe provided `Sender`.",0,null],[13,"Body","","Body frame. None indicates that the body is done streaming.",0,null],[13,"Error","","Error",0,null],[13,"Done","","Final frame sent in each transport direction",0,null],[4,"Message","","Message sent and received from a multiplexed service",null,null],[13,"WithoutBody","","Has no associated streaming body",1,null],[13,"WithBody","","Has associated streaming body",1,null],[4,"Error","","Error returned as an Error frame or an `io::Error` that occurerred during\nnormal processing of the Transport",null,null],[13,"Transport","","Transport frame level error",2,null],[13,"Io","","I/O level error",2,null],[11,"new","","Create a new pipeline `Server` dispatcher with the given service and\ntransport",3,{"inputs":[{"name":"s"},{"name":"t"}],"output":{"name":"result"}}],[11,"poll","","",3,null],[6,"RequestId","","Identifies a request / response thread",null,null],[8,"ServerService","","A specialization of `Service` supporting the requirements of server\npipelined services",null,null],[16,"Request","","Requests handled by the service.",4,null],[16,"Response","","Responses given by the service.",4,null],[16,"Body","","Response body chunk",4,null],[16,"BodyStream","","Response body stream",4,null],[16,"Error","","Errors produced by the service.",4,null],[16,"Future","","The future response value.",4,null],[10,"call","","Process the request and return the response asynchronously.",4,null],[8,"Transport","","A specialization of `io::Transport` supporting the requirements of\npipeline based protocols.",null,null],[16,"In","","Messages written to the transport",5,null],[16,"BodyIn","","Inbound body frame",5,null],[16,"Out","","Messages read from the transport",5,null],[16,"BodyOut","","Outbound body frame",5,null],[16,"Error","","Transport error",5,null],[10,"poll_read","","Tests to see if this Transport may be readable.",5,null],[10,"read","","Read a message from the `Transport`",5,null],[10,"poll_write","","Tests to see if this I/O object may be writable.",5,null],[10,"write","","Write a message to the `Transport`",5,null],[10,"flush","","Flush pending writes to the socket",5,null],[8,"NewTransport","","A specialization of `io::NewTransport` supporting the requirements of\npipeline based protocols.",null,null],[16,"In","","Messages written to the transport",6,null],[16,"BodyIn","","Inbound streaming body",6,null],[16,"Out","","Messages read from the transport",6,null],[16,"BodyOut","","Outbound streaming body",6,null],[16,"Error","","Errors",6,null],[16,"Item","","Transport returned",6,null],[10,"new_transport","","Create and return a new `Transport`",6,null],[11,"request_id","","Return the request ID associated with the frame.",0,null],[11,"unwrap_msg","","Unwraps a frame, yielding the content of the `Message`.",0,null],[11,"unwrap_body","","Unwraps a frame, yielding the content of the `Body`.",0,null],[11,"unwrap_err","","Unwraps a frame, yielding the content of the `Error`.",0,null],[11,"is_done","","Returns true if the frame is `Frame::Done`",0,null],[11,"fmt","","",0,null],[11,"take_body","","If the `Message` value has an associated body stream, return it. The\noriginal `Message` value will then become a `WithoutBody` variant.",1,null],[11,"eq","","",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"fmt","","",1,null],[11,"new_transport","take","",7,null],[11,"from","std::io::error","",8,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"pipeline","tokio_proto","A dispatcher for pipelining protocols",null,null],[3,"Client","tokio_proto::pipeline","Client `Service` for the pipeline protocol.",null,null],[3,"Server","","A server `Task` that dispatches `Transport` messages to a `Service` using\nprotocol pipelining.",null,null],[4,"Frame","","A pipelined protocol frame",null,null],[13,"Message","","Either a request or a response",9,null],[13,"MessageWithBody","","Returned by `Transport::read` when a streaming body will follow.\nSubsequent body frames will be proxied to the provided `Sender`.",9,null],[13,"Body","","Body frame. None indicates that the body is done streaming.",9,null],[13,"Error","","Error",9,null],[13,"Done","","Final frame sent in each transport direction",9,null],[4,"Message","","Message sent and received from a pipeline service",null,null],[13,"WithoutBody","","Has no associated streaming body",10,null],[13,"WithBody","","Has associated streaming body",10,null],[4,"Error","","Error returned as an Error frame or an `io::Error` that occurerred during\nnormal processing of the Transport",null,null],[13,"Transport","","Transport frame level error",11,null],[13,"Io","","I/O level error",11,null],[5,"connect","","Connect to the given `addr` and handle using the given Transport and protocol pipelining.",null,{"inputs":[{"name":"handle"},{"name":"t"}],"output":{"name":"result"}}],[11,"call","","",12,null],[11,"poll_ready","","",12,null],[11,"clone","","",12,null],[11,"new","","Create a new pipeline `Server` dispatcher with the given service and\ntransport",13,{"inputs":[{"name":"s"},{"name":"t"}],"output":{"name":"result"}}],[11,"poll","","",13,null],[8,"ServerService","","A specialization of `Service` supporting the requirements of server\npipelined services",null,null],[16,"Request","","Requests handled by the service.",14,null],[16,"Response","","Responses given by the service.",14,null],[16,"Body","","Response body chunk",14,null],[16,"BodyStream","","Response body stream",14,null],[16,"Error","","Errors produced by the service.",14,null],[16,"Future","","The future response value.",14,null],[10,"call","","Process the request and return the response asynchronously.",14,null],[8,"Transport","","A specialization of `io::Transport` supporting the requirements of\npipeline based protocols.",null,null],[16,"In","","Messages written to the transport",15,null],[16,"BodyIn","","Inbound body frame",15,null],[16,"Out","","Messages read from the transport",15,null],[16,"BodyOut","","Outbound body frame",15,null],[16,"Error","","Transport error",15,null],[10,"poll_read","","Tests to see if this Transport may be readable.",15,null],[10,"read","","Read a message from the `Transport`",15,null],[10,"poll_write","","Tests to see if this I/O object may be writable.",15,null],[10,"write","","Write a message to the `Transport`",15,null],[10,"flush","","Flush pending writes to the socket",15,null],[8,"NewTransport","","A specialization of `io::NewTransport` supporting the requirements of\npipeline based protocols.",null,null],[16,"In","","Messages written to the transport",16,null],[16,"BodyIn","","Inbound streaming body",16,null],[16,"Out","","Messages read from the transport",16,null],[16,"BodyOut","","Outbound streaming body",16,null],[16,"Error","","Errors",16,null],[16,"Item","","Transport returned",16,null],[10,"new_transport","","Create and return a new `Transport`",16,null],[11,"unwrap_msg","","Unwraps a frame, yielding the content of the `Message`.",9,null],[11,"unwrap_body","","Unwraps a frame, yielding the content of the `Body`.",9,null],[11,"unwrap_err","","Unwraps a frame, yielding the content of the `Error`.",9,null],[11,"is_done","","Returns true if the frame is `Frame::Done`",9,null],[11,"fmt","","",9,null],[11,"take_body","","If the `Message` value has an associated body stream, return it. The\noriginal `Message` value will then become a `WithoutBody` variant.",10,null],[11,"eq","","",10,null],[11,"deref","","",10,null],[11,"deref_mut","","",10,null],[11,"fmt","","",10,null],[11,"new_transport","take","",7,null],[11,"from","std::io::error","",8,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"server","tokio_proto","A generic Tokio TCP server implementation.",null,null],[3,"ServerHandle","tokio_proto::server","A handle to a running server.",null,null],[5,"listen","","Spawn a new `Task` that binds to the given `addr` then accepts all incoming\nconnections; dispatching them to tasks created by `new_task`.",null,{"inputs":[{"name":"handle"},{"name":"socketaddr"},{"name":"t"}],"output":{"name":"result"}}],[8,"NewTask","","Create a new `Task` to handle a server socket.",null,null],[16,"Item","","The `Task` value created by this factory",17,null],[10,"new_task","","Create and return a new `Task` value",17,null],[11,"local_addr","","Returns the local socket address of the `TcpListener` for this server.",18,null],[11,"new_task","take","",7,null],[11,"new","tokio_proto","Create a new `Framed`",19,{"inputs":[{"name":"t"},{"name":"p"},{"name":"s"},{"name":"blockbuf"},{"name":"blockbuf"}],"output":{"name":"framed"}}],[11,"poll_read","","",19,null],[11,"read","","",19,null],[11,"poll_write","","",19,null],[11,"write","","",19,null],[11,"flush","","",19,null],[8,"Parse","","Parses frames out of a `BlockBuf`",null,null],[16,"Out","","Parse result",20,null],[10,"parse","","Optionally parse a frame from the given buffer.",20,null],[11,"done","","Called when there are no more inbound bytes",20,null],[8,"Serialize","","Serialize frames into a `BlockBuf`",null,null],[16,"In","","Type to serialize",21,null],[10,"serialize","","Serialize the frame into the `BlockBuf`",21,null],[8,"TryRead","","A refinement of `std::io::Read` for reading from non-blocking sources.",null,null],[10,"try_read","","Pull some bytes from this source into the specified buffer, returning\nhow many bytes were read.",22,null],[10,"try_read_buf","","Pull some bytes from this source into the specified `Buf`, returning\nhow many bytes were read.",22,null],[8,"TryWrite","","A refinement of `std::io::Write` for reading from non-blocking sources.",null,null],[10,"try_write","","Write a buffer into this object, returning how many bytes were written.",23,null],[10,"try_write_buf","","Write a `Buf` into this object, returning how many bytes were written.",23,null],[10,"try_flush","","Try flushing the underlying IO",23,null],[11,"done","","Called when there are no more inbound bytes",20,null]],"paths":[[4,"Frame"],[4,"Message"],[4,"Error"],[3,"Server"],[8,"ServerService"],[8,"Transport"],[8,"NewTransport"],[3,"Take"],[3,"Error"],[4,"Frame"],[4,"Message"],[4,"Error"],[3,"Client"],[3,"Server"],[8,"ServerService"],[8,"Transport"],[8,"NewTransport"],[8,"NewTask"],[3,"ServerHandle"],[3,"Framed"],[8,"Parse"],[8,"Serialize"],[8,"TryRead"],[8,"TryWrite"]]};
initSearch(searchIndex);
